/*
Copyright 2023 IONOS Cloud.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by mockery v2.36.0. DO NOT EDIT.

package client_test

import (
	context "context"

	ionoscloud "github.com/ionos-cloud/sdk-go/v6"

	mock "github.com/stretchr/testify/mock"
)

// MockClient is an autogenerated mock type for the Client type
type MockClient struct {
	mock.Mock
}

type MockClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockClient) EXPECT() *MockClient_Expecter {
	return &MockClient_Expecter{mock: &_m.Mock}
}

// AttachToLAN provides a mock function with given fields: ctx, dataCenterID, lanID, nic
func (_m *MockClient) AttachToLAN(ctx context.Context, dataCenterID string, lanID string, nic ionoscloud.Nic) (*ionoscloud.Nic, error) {
	ret := _m.Called(ctx, dataCenterID, lanID, nic)

	var r0 *ionoscloud.Nic
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ionoscloud.Nic) (*ionoscloud.Nic, error)); ok {
		return rf(ctx, dataCenterID, lanID, nic)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ionoscloud.Nic) *ionoscloud.Nic); ok {
		r0 = rf(ctx, dataCenterID, lanID, nic)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ionoscloud.Nic)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, ionoscloud.Nic) error); ok {
		r1 = rf(ctx, dataCenterID, lanID, nic)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_AttachToLAN_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AttachToLAN'
type MockClient_AttachToLAN_Call struct {
	*mock.Call
}

// AttachToLAN is a helper method to define mock.On call
//   - ctx context.Context
//   - dataCenterID string
//   - lanID string
//   - nic ionoscloud.Nic
func (_e *MockClient_Expecter) AttachToLAN(ctx interface{}, dataCenterID interface{}, lanID interface{}, nic interface{}) *MockClient_AttachToLAN_Call {
	return &MockClient_AttachToLAN_Call{Call: _e.mock.On("AttachToLAN", ctx, dataCenterID, lanID, nic)}
}

func (_c *MockClient_AttachToLAN_Call) Run(run func(ctx context.Context, dataCenterID string, lanID string, nic ionoscloud.Nic)) *MockClient_AttachToLAN_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(ionoscloud.Nic))
	})
	return _c
}

func (_c *MockClient_AttachToLAN_Call) Return(_a0 *ionoscloud.Nic, _a1 error) *MockClient_AttachToLAN_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_AttachToLAN_Call) RunAndReturn(run func(context.Context, string, string, ionoscloud.Nic) (*ionoscloud.Nic, error)) *MockClient_AttachToLAN_Call {
	_c.Call.Return(run)
	return _c
}

// CreateDataCenter provides a mock function with given fields: ctx, properties
func (_m *MockClient) CreateDataCenter(ctx context.Context, properties ionoscloud.DatacenterProperties) (*ionoscloud.Datacenter, error) {
	ret := _m.Called(ctx, properties)

	var r0 *ionoscloud.Datacenter
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ionoscloud.DatacenterProperties) (*ionoscloud.Datacenter, error)); ok {
		return rf(ctx, properties)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ionoscloud.DatacenterProperties) *ionoscloud.Datacenter); ok {
		r0 = rf(ctx, properties)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ionoscloud.Datacenter)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ionoscloud.DatacenterProperties) error); ok {
		r1 = rf(ctx, properties)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_CreateDataCenter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDataCenter'
type MockClient_CreateDataCenter_Call struct {
	*mock.Call
}

// CreateDataCenter is a helper method to define mock.On call
//   - ctx context.Context
//   - properties ionoscloud.DatacenterProperties
func (_e *MockClient_Expecter) CreateDataCenter(ctx interface{}, properties interface{}) *MockClient_CreateDataCenter_Call {
	return &MockClient_CreateDataCenter_Call{Call: _e.mock.On("CreateDataCenter", ctx, properties)}
}

func (_c *MockClient_CreateDataCenter_Call) Run(run func(ctx context.Context, properties ionoscloud.DatacenterProperties)) *MockClient_CreateDataCenter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ionoscloud.DatacenterProperties))
	})
	return _c
}

func (_c *MockClient_CreateDataCenter_Call) Return(_a0 *ionoscloud.Datacenter, _a1 error) *MockClient_CreateDataCenter_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_CreateDataCenter_Call) RunAndReturn(run func(context.Context, ionoscloud.DatacenterProperties) (*ionoscloud.Datacenter, error)) *MockClient_CreateDataCenter_Call {
	_c.Call.Return(run)
	return _c
}

// CreateLAN provides a mock function with given fields: ctx, dataCenterID, properties
func (_m *MockClient) CreateLAN(ctx context.Context, dataCenterID string, properties ionoscloud.LanPropertiesPost) (*ionoscloud.LanPost, error) {
	ret := _m.Called(ctx, dataCenterID, properties)

	var r0 *ionoscloud.LanPost
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ionoscloud.LanPropertiesPost) (*ionoscloud.LanPost, error)); ok {
		return rf(ctx, dataCenterID, properties)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ionoscloud.LanPropertiesPost) *ionoscloud.LanPost); ok {
		r0 = rf(ctx, dataCenterID, properties)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ionoscloud.LanPost)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ionoscloud.LanPropertiesPost) error); ok {
		r1 = rf(ctx, dataCenterID, properties)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_CreateLAN_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLAN'
type MockClient_CreateLAN_Call struct {
	*mock.Call
}

// CreateLAN is a helper method to define mock.On call
//   - ctx context.Context
//   - dataCenterID string
//   - properties ionoscloud.LanPropertiesPost
func (_e *MockClient_Expecter) CreateLAN(ctx interface{}, dataCenterID interface{}, properties interface{}) *MockClient_CreateLAN_Call {
	return &MockClient_CreateLAN_Call{Call: _e.mock.On("CreateLAN", ctx, dataCenterID, properties)}
}

func (_c *MockClient_CreateLAN_Call) Run(run func(ctx context.Context, dataCenterID string, properties ionoscloud.LanPropertiesPost)) *MockClient_CreateLAN_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(ionoscloud.LanPropertiesPost))
	})
	return _c
}

func (_c *MockClient_CreateLAN_Call) Return(_a0 *ionoscloud.LanPost, _a1 error) *MockClient_CreateLAN_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_CreateLAN_Call) RunAndReturn(run func(context.Context, string, ionoscloud.LanPropertiesPost) (*ionoscloud.LanPost, error)) *MockClient_CreateLAN_Call {
	_c.Call.Return(run)
	return _c
}

// CreateServer provides a mock function with given fields: ctx, dataCenterID, properties
func (_m *MockClient) CreateServer(ctx context.Context, dataCenterID string, properties ionoscloud.ServerProperties) (*ionoscloud.Server, error) {
	ret := _m.Called(ctx, dataCenterID, properties)

	var r0 *ionoscloud.Server
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ionoscloud.ServerProperties) (*ionoscloud.Server, error)); ok {
		return rf(ctx, dataCenterID, properties)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ionoscloud.ServerProperties) *ionoscloud.Server); ok {
		r0 = rf(ctx, dataCenterID, properties)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ionoscloud.Server)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ionoscloud.ServerProperties) error); ok {
		r1 = rf(ctx, dataCenterID, properties)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_CreateServer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateServer'
type MockClient_CreateServer_Call struct {
	*mock.Call
}

// CreateServer is a helper method to define mock.On call
//   - ctx context.Context
//   - dataCenterID string
//   - properties ionoscloud.ServerProperties
func (_e *MockClient_Expecter) CreateServer(ctx interface{}, dataCenterID interface{}, properties interface{}) *MockClient_CreateServer_Call {
	return &MockClient_CreateServer_Call{Call: _e.mock.On("CreateServer", ctx, dataCenterID, properties)}
}

func (_c *MockClient_CreateServer_Call) Run(run func(ctx context.Context, dataCenterID string, properties ionoscloud.ServerProperties)) *MockClient_CreateServer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(ionoscloud.ServerProperties))
	})
	return _c
}

func (_c *MockClient_CreateServer_Call) Return(_a0 *ionoscloud.Server, _a1 error) *MockClient_CreateServer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_CreateServer_Call) RunAndReturn(run func(context.Context, string, ionoscloud.ServerProperties) (*ionoscloud.Server, error)) *MockClient_CreateServer_Call {
	_c.Call.Return(run)
	return _c
}

// DestroyLAN provides a mock function with given fields: ctx, dataCenterID, lanID
func (_m *MockClient) DestroyLAN(ctx context.Context, dataCenterID string, lanID string) error {
	ret := _m.Called(ctx, dataCenterID, lanID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, dataCenterID, lanID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DestroyLAN_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestroyLAN'
type MockClient_DestroyLAN_Call struct {
	*mock.Call
}

// DestroyLAN is a helper method to define mock.On call
//   - ctx context.Context
//   - dataCenterID string
//   - lanID string
func (_e *MockClient_Expecter) DestroyLAN(ctx interface{}, dataCenterID interface{}, lanID interface{}) *MockClient_DestroyLAN_Call {
	return &MockClient_DestroyLAN_Call{Call: _e.mock.On("DestroyLAN", ctx, dataCenterID, lanID)}
}

func (_c *MockClient_DestroyLAN_Call) Run(run func(ctx context.Context, dataCenterID string, lanID string)) *MockClient_DestroyLAN_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_DestroyLAN_Call) Return(_a0 error) *MockClient_DestroyLAN_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DestroyLAN_Call) RunAndReturn(run func(context.Context, string, string) error) *MockClient_DestroyLAN_Call {
	_c.Call.Return(run)
	return _c
}

// DestroyServer provides a mock function with given fields: ctx, dataCenterID, serverID
func (_m *MockClient) DestroyServer(ctx context.Context, dataCenterID string, serverID string) error {
	ret := _m.Called(ctx, dataCenterID, serverID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, dataCenterID, serverID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DestroyServer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestroyServer'
type MockClient_DestroyServer_Call struct {
	*mock.Call
}

// DestroyServer is a helper method to define mock.On call
//   - ctx context.Context
//   - dataCenterID string
//   - serverID string
func (_e *MockClient_Expecter) DestroyServer(ctx interface{}, dataCenterID interface{}, serverID interface{}) *MockClient_DestroyServer_Call {
	return &MockClient_DestroyServer_Call{Call: _e.mock.On("DestroyServer", ctx, dataCenterID, serverID)}
}

func (_c *MockClient_DestroyServer_Call) Run(run func(ctx context.Context, dataCenterID string, serverID string)) *MockClient_DestroyServer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_DestroyServer_Call) Return(_a0 error) *MockClient_DestroyServer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DestroyServer_Call) RunAndReturn(run func(context.Context, string, string) error) *MockClient_DestroyServer_Call {
	_c.Call.Return(run)
	return _c
}

// DestroyVolume provides a mock function with given fields: ctx, dataCenterID, volumeID
func (_m *MockClient) DestroyVolume(ctx context.Context, dataCenterID string, volumeID string) error {
	ret := _m.Called(ctx, dataCenterID, volumeID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, dataCenterID, volumeID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DestroyVolume_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestroyVolume'
type MockClient_DestroyVolume_Call struct {
	*mock.Call
}

// DestroyVolume is a helper method to define mock.On call
//   - ctx context.Context
//   - dataCenterID string
//   - volumeID string
func (_e *MockClient_Expecter) DestroyVolume(ctx interface{}, dataCenterID interface{}, volumeID interface{}) *MockClient_DestroyVolume_Call {
	return &MockClient_DestroyVolume_Call{Call: _e.mock.On("DestroyVolume", ctx, dataCenterID, volumeID)}
}

func (_c *MockClient_DestroyVolume_Call) Run(run func(ctx context.Context, dataCenterID string, volumeID string)) *MockClient_DestroyVolume_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_DestroyVolume_Call) Return(_a0 error) *MockClient_DestroyVolume_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DestroyVolume_Call) RunAndReturn(run func(context.Context, string, string) error) *MockClient_DestroyVolume_Call {
	_c.Call.Return(run)
	return _c
}

// GetDataCenter provides a mock function with given fields: ctx, dataCenterID
func (_m *MockClient) GetDataCenter(ctx context.Context, dataCenterID string) (*ionoscloud.Datacenter, error) {
	ret := _m.Called(ctx, dataCenterID)

	var r0 *ionoscloud.Datacenter
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*ionoscloud.Datacenter, error)); ok {
		return rf(ctx, dataCenterID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *ionoscloud.Datacenter); ok {
		r0 = rf(ctx, dataCenterID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ionoscloud.Datacenter)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, dataCenterID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetDataCenter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDataCenter'
type MockClient_GetDataCenter_Call struct {
	*mock.Call
}

// GetDataCenter is a helper method to define mock.On call
//   - ctx context.Context
//   - dataCenterID string
func (_e *MockClient_Expecter) GetDataCenter(ctx interface{}, dataCenterID interface{}) *MockClient_GetDataCenter_Call {
	return &MockClient_GetDataCenter_Call{Call: _e.mock.On("GetDataCenter", ctx, dataCenterID)}
}

func (_c *MockClient_GetDataCenter_Call) Run(run func(ctx context.Context, dataCenterID string)) *MockClient_GetDataCenter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_GetDataCenter_Call) Return(_a0 *ionoscloud.Datacenter, _a1 error) *MockClient_GetDataCenter_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetDataCenter_Call) RunAndReturn(run func(context.Context, string) (*ionoscloud.Datacenter, error)) *MockClient_GetDataCenter_Call {
	_c.Call.Return(run)
	return _c
}

// GetLAN provides a mock function with given fields: ctx, dataCenterID, lanID
func (_m *MockClient) GetLAN(ctx context.Context, dataCenterID string, lanID string) (*ionoscloud.Lan, error) {
	ret := _m.Called(ctx, dataCenterID, lanID)

	var r0 *ionoscloud.Lan
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*ionoscloud.Lan, error)); ok {
		return rf(ctx, dataCenterID, lanID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *ionoscloud.Lan); ok {
		r0 = rf(ctx, dataCenterID, lanID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ionoscloud.Lan)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, dataCenterID, lanID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetLAN_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLAN'
type MockClient_GetLAN_Call struct {
	*mock.Call
}

// GetLAN is a helper method to define mock.On call
//   - ctx context.Context
//   - dataCenterID string
//   - lanID string
func (_e *MockClient_Expecter) GetLAN(ctx interface{}, dataCenterID interface{}, lanID interface{}) *MockClient_GetLAN_Call {
	return &MockClient_GetLAN_Call{Call: _e.mock.On("GetLAN", ctx, dataCenterID, lanID)}
}

func (_c *MockClient_GetLAN_Call) Run(run func(ctx context.Context, dataCenterID string, lanID string)) *MockClient_GetLAN_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_GetLAN_Call) Return(_a0 *ionoscloud.Lan, _a1 error) *MockClient_GetLAN_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetLAN_Call) RunAndReturn(run func(context.Context, string, string) (*ionoscloud.Lan, error)) *MockClient_GetLAN_Call {
	_c.Call.Return(run)
	return _c
}

// GetServer provides a mock function with given fields: ctx, dataCenterID, serverID
func (_m *MockClient) GetServer(ctx context.Context, dataCenterID string, serverID string) (*ionoscloud.Server, error) {
	ret := _m.Called(ctx, dataCenterID, serverID)

	var r0 *ionoscloud.Server
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*ionoscloud.Server, error)); ok {
		return rf(ctx, dataCenterID, serverID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *ionoscloud.Server); ok {
		r0 = rf(ctx, dataCenterID, serverID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ionoscloud.Server)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, dataCenterID, serverID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetServer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetServer'
type MockClient_GetServer_Call struct {
	*mock.Call
}

// GetServer is a helper method to define mock.On call
//   - ctx context.Context
//   - dataCenterID string
//   - serverID string
func (_e *MockClient_Expecter) GetServer(ctx interface{}, dataCenterID interface{}, serverID interface{}) *MockClient_GetServer_Call {
	return &MockClient_GetServer_Call{Call: _e.mock.On("GetServer", ctx, dataCenterID, serverID)}
}

func (_c *MockClient_GetServer_Call) Run(run func(ctx context.Context, dataCenterID string, serverID string)) *MockClient_GetServer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_GetServer_Call) Return(_a0 *ionoscloud.Server, _a1 error) *MockClient_GetServer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetServer_Call) RunAndReturn(run func(context.Context, string, string) (*ionoscloud.Server, error)) *MockClient_GetServer_Call {
	_c.Call.Return(run)
	return _c
}

// GetVolume provides a mock function with given fields: ctx, dataCenterID, volumeID
func (_m *MockClient) GetVolume(ctx context.Context, dataCenterID string, volumeID string) (*ionoscloud.Volume, error) {
	ret := _m.Called(ctx, dataCenterID, volumeID)

	var r0 *ionoscloud.Volume
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*ionoscloud.Volume, error)); ok {
		return rf(ctx, dataCenterID, volumeID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *ionoscloud.Volume); ok {
		r0 = rf(ctx, dataCenterID, volumeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ionoscloud.Volume)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, dataCenterID, volumeID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetVolume_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVolume'
type MockClient_GetVolume_Call struct {
	*mock.Call
}

// GetVolume is a helper method to define mock.On call
//   - ctx context.Context
//   - dataCenterID string
//   - volumeID string
func (_e *MockClient_Expecter) GetVolume(ctx interface{}, dataCenterID interface{}, volumeID interface{}) *MockClient_GetVolume_Call {
	return &MockClient_GetVolume_Call{Call: _e.mock.On("GetVolume", ctx, dataCenterID, volumeID)}
}

func (_c *MockClient_GetVolume_Call) Run(run func(ctx context.Context, dataCenterID string, volumeID string)) *MockClient_GetVolume_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_GetVolume_Call) Return(_a0 *ionoscloud.Volume, _a1 error) *MockClient_GetVolume_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetVolume_Call) RunAndReturn(run func(context.Context, string, string) (*ionoscloud.Volume, error)) *MockClient_GetVolume_Call {
	_c.Call.Return(run)
	return _c
}

// ListLANs provides a mock function with given fields: ctx, dataCenterID
func (_m *MockClient) ListLANs(ctx context.Context, dataCenterID string) (*ionoscloud.Lans, error) {
	ret := _m.Called(ctx, dataCenterID)

	var r0 *ionoscloud.Lans
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*ionoscloud.Lans, error)); ok {
		return rf(ctx, dataCenterID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *ionoscloud.Lans); ok {
		r0 = rf(ctx, dataCenterID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ionoscloud.Lans)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, dataCenterID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_ListLANs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListLANs'
type MockClient_ListLANs_Call struct {
	*mock.Call
}

// ListLANs is a helper method to define mock.On call
//   - ctx context.Context
//   - dataCenterID string
func (_e *MockClient_Expecter) ListLANs(ctx interface{}, dataCenterID interface{}) *MockClient_ListLANs_Call {
	return &MockClient_ListLANs_Call{Call: _e.mock.On("ListLANs", ctx, dataCenterID)}
}

func (_c *MockClient_ListLANs_Call) Run(run func(ctx context.Context, dataCenterID string)) *MockClient_ListLANs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_ListLANs_Call) Return(_a0 *ionoscloud.Lans, _a1 error) *MockClient_ListLANs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_ListLANs_Call) RunAndReturn(run func(context.Context, string) (*ionoscloud.Lans, error)) *MockClient_ListLANs_Call {
	_c.Call.Return(run)
	return _c
}

// ListServers provides a mock function with given fields: ctx, dataCenterID
func (_m *MockClient) ListServers(ctx context.Context, dataCenterID string) (*ionoscloud.Servers, error) {
	ret := _m.Called(ctx, dataCenterID)

	var r0 *ionoscloud.Servers
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*ionoscloud.Servers, error)); ok {
		return rf(ctx, dataCenterID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *ionoscloud.Servers); ok {
		r0 = rf(ctx, dataCenterID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ionoscloud.Servers)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, dataCenterID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_ListServers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListServers'
type MockClient_ListServers_Call struct {
	*mock.Call
}

// ListServers is a helper method to define mock.On call
//   - ctx context.Context
//   - dataCenterID string
func (_e *MockClient_Expecter) ListServers(ctx interface{}, dataCenterID interface{}) *MockClient_ListServers_Call {
	return &MockClient_ListServers_Call{Call: _e.mock.On("ListServers", ctx, dataCenterID)}
}

func (_c *MockClient_ListServers_Call) Run(run func(ctx context.Context, dataCenterID string)) *MockClient_ListServers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_ListServers_Call) Return(_a0 *ionoscloud.Servers, _a1 error) *MockClient_ListServers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_ListServers_Call) RunAndReturn(run func(context.Context, string) (*ionoscloud.Servers, error)) *MockClient_ListServers_Call {
	_c.Call.Return(run)
	return _c
}

// ListVolumes provides a mock function with given fields: ctx, dataCenterID
func (_m *MockClient) ListVolumes(ctx context.Context, dataCenterID string) (*ionoscloud.Volumes, error) {
	ret := _m.Called(ctx, dataCenterID)

	var r0 *ionoscloud.Volumes
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*ionoscloud.Volumes, error)); ok {
		return rf(ctx, dataCenterID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *ionoscloud.Volumes); ok {
		r0 = rf(ctx, dataCenterID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ionoscloud.Volumes)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, dataCenterID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_ListVolumes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListVolumes'
type MockClient_ListVolumes_Call struct {
	*mock.Call
}

// ListVolumes is a helper method to define mock.On call
//   - ctx context.Context
//   - dataCenterID string
func (_e *MockClient_Expecter) ListVolumes(ctx interface{}, dataCenterID interface{}) *MockClient_ListVolumes_Call {
	return &MockClient_ListVolumes_Call{Call: _e.mock.On("ListVolumes", ctx, dataCenterID)}
}

func (_c *MockClient_ListVolumes_Call) Run(run func(ctx context.Context, dataCenterID string)) *MockClient_ListVolumes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_ListVolumes_Call) Return(_a0 *ionoscloud.Volumes, _a1 error) *MockClient_ListVolumes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_ListVolumes_Call) RunAndReturn(run func(context.Context, string) (*ionoscloud.Volumes, error)) *MockClient_ListVolumes_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateLAN provides a mock function with given fields: ctx, dataCenterID, lanID, properties
func (_m *MockClient) UpdateLAN(ctx context.Context, dataCenterID string, lanID string, properties ionoscloud.LanProperties) (*ionoscloud.Lan, error) {
	ret := _m.Called(ctx, dataCenterID, lanID, properties)

	var r0 *ionoscloud.Lan
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ionoscloud.LanProperties) (*ionoscloud.Lan, error)); ok {
		return rf(ctx, dataCenterID, lanID, properties)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ionoscloud.LanProperties) *ionoscloud.Lan); ok {
		r0 = rf(ctx, dataCenterID, lanID, properties)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ionoscloud.Lan)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, ionoscloud.LanProperties) error); ok {
		r1 = rf(ctx, dataCenterID, lanID, properties)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_UpdateLAN_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateLAN'
type MockClient_UpdateLAN_Call struct {
	*mock.Call
}

// UpdateLAN is a helper method to define mock.On call
//   - ctx context.Context
//   - dataCenterID string
//   - lanID string
//   - properties ionoscloud.LanProperties
func (_e *MockClient_Expecter) UpdateLAN(ctx interface{}, dataCenterID interface{}, lanID interface{}, properties interface{}) *MockClient_UpdateLAN_Call {
	return &MockClient_UpdateLAN_Call{Call: _e.mock.On("UpdateLAN", ctx, dataCenterID, lanID, properties)}
}

func (_c *MockClient_UpdateLAN_Call) Run(run func(ctx context.Context, dataCenterID string, lanID string, properties ionoscloud.LanProperties)) *MockClient_UpdateLAN_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(ionoscloud.LanProperties))
	})
	return _c
}

func (_c *MockClient_UpdateLAN_Call) Return(_a0 *ionoscloud.Lan, _a1 error) *MockClient_UpdateLAN_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_UpdateLAN_Call) RunAndReturn(run func(context.Context, string, string, ionoscloud.LanProperties) (*ionoscloud.Lan, error)) *MockClient_UpdateLAN_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockClient creates a new instance of MockClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockClient {
	mock := &MockClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
